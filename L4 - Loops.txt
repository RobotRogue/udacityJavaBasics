Hello notes! https://classroom.udacity.com/courses/ud282/lessons/8192650550/concepts/38f71cca-9f97-4fbd-baee-7c39914b9376

###L4 Loops

#Loop Types:
There are 3 loop types in Java:

1) While loop - A while loop statement in Java programming language repeatedly executes a target statement as long as a given condition is true.
  while(Boolean_expression) {
     // Statements
  }

2) For loop - A for loop is a repetition control structure that allows you to efficiently write a loop that needs to be executed a specific number of times.
  for(initialization; Boolean_expression; update) {
     // Statements
  }

3) Do-While loop - A do...while loop is similar to a while loop, except that a do...while loop is guaranteed to execute at least one time.
  do {
     // Statements
  }while(Boolean_expression);


#Alarm
Say you wanted to create an alarm that continues to go off until it is stopped.

Here are some functions that help that happen:

  public void beep () {
    // Makes a single beep sound
  }

  public boolean checkAlarm () {
    // Returns true if the alarm is on, false if it is off
  }

  public void alarm () {
    // Keep beeping until it is snoozed
    boolean on = checkAlarm();
    if (on) {
      beep();
      on = checkAlarm(); // but this only runs once... how do we get it to continually check?
    }
  }

In this case we can use a while loop. ;)


#While Loops
while loops allow you to repeat an if condition over and over for as long as that condition remains true, hence the name while!

To create a while loop, simply follow the same steps like an if condition, but replace the if with a while to look something like this:

  while(isRaining){
     System.out.println("It's still raining outside!");
     isRaining = checkWeather();
  }
  System.out.println("Now it's not raining anymore");

This code block above will continue to print the message "It's still raining outside!" for
as long as the boolean isRaining is true, once the function checkWeather() returns false
isRaining will no longer be true, so the while loop would end and the message "Now it's not raining anymore" will be displayed.

Unlike if blocks however, while loops don't have else blocks, they are simply like a repeated if block that would only end when the condition becomes false.


#Quiz - Googol
Can you write a while loop that would print out a googol? (1 with 100 zeroes behind it?)

  String googol = "1"; // Creates a string variable.
  int len = googol.length(); // Creates a length of string variable.

  while (len < 101) { // While length of string is less than 101... do what is in codeblock.
    googol = googol + "0"; // Adds a "0" to the end of the string.
    len = googol.length(); // Reads the length of the new string, and passes that value to the loop.
  }


#Yahtzee! - It's a Match!
The problem we are trying to solve is to count the number of times we need to roll 5 dice to get a Yahtzee.
Instead we should first simplify the problem down to rolling two dice and going from there.

So to simplify, start with writing code that will roll two dice and compare if they are equal or not.
Once you have that code, you can then add more dice to the code, to solve the end problem.

Here is code for rolling two dice:

  public int keeprolling () {
    int dice1 = rollDice(); // stores the value of first dice roll
    int dice2 = rollDice(); // stores the value of the second dice roll
    int count = 1; // Sets a counter to keep track of the number of rolls

    while (!(dice1 == dice2)) { // while the value of dice1 and dice2 is NOT equal, do this
      // We need to re-roll
      dice1 = rollDice(); // stores the value of first dice roll
      dice2 = rollDice(); // stores the value of second dice roll
      count = count + 1; // Increments counter to keep track of retries
    }
    return count; // When they finally match, return the number of tries it took.
  }

So the above handles 2 dice. Starting simple, but we wanted 6... let's keep going.


#Quiz; Three Dice
With the above code, we were able to get the values of two dicerolls and compare their equality.
Now how would we handle if there needed to be a third dice?

  public int keeprolling () {
    int dice1 = rollDice(); // stores the value of first dice roll
    int dice2 = rollDice(); // stores the value of the second dice roll
    int dice3 = rollDice(); // stores the value of the third dice roll
    int count = 1; // Sets a counter to keep track of the number of rolls

    while (!(dice1 == dice2 == dice3)) { // THIS WONT WORK - SO HOW DO WE GET IT TO WORK?
      // We need to re-roll
      dice1 = rollDice(); // stores the value of first dice roll
      dice2 = rollDice(); // stores the value of second dice roll
      dice3 = rollDice(); // stores the value of third dice roll
      count = count + 1; // Increments counter to keep track of retries
    }
    return count; // When they finally match, return the number of tries it took.
  }

What should the conditional statement be instead to get it to work?

My Answer: !(dice1 == dice 2 && dice2 == dice3)

But how does that work?

It will compare the values of dice1 to dice2, and compare the values of dice2 to dice3
If dice1, dice2 AND dice2, dice3 are all equal, then the condition would equate to true... but its !(true) - which evaluates to false, exiting the loop.
If any of them are a mismatch, any of them will cause it to equate to false, and the !(false) equates to true, going into the loop.

That one takes a bit to wrap your head around, go over it a few times to make sure you understand why that would work.

And for funsies, also try to figure out why these would NOT work:

  while (dice1 == dice2 || dice2 == dice3)
  while (dice1 && dice2 && dice2 == dice3)
  while (dice1 != dice2 && dice2 != dice3)

Easiest way to figure out why is to try writing out the examples, with some true and false test values.


Quiz: Roll A Yahtzee
You should modify the function int keepRolling() by adding code to check for a 5 dice match (Yahtzee) rather than just 3 dice.

To do so, follow these steps:

Add 2 new integer variables dice4 and dice5 and initialize them to the function call rollDice()
Then inside the while loop, make sure you reset the values of those integers to another call of rollDice() each.
Finally, update the while loop condition to check for the mismatch of all 5 dice.
Remember you can simply check that all dice match and surround that with the ! not operator like with the existing 3 dice implementation.

  public int keepRolling() {
      int dice1 = rollDice();
      int dice2 = rollDice();
      int dice3 = rollDice();
      int dice4 = rollDice();
      int dice5 = rollDice();
      int count = 1;

      while (!(dice1 == dice2 && dice2 == dice3 &&
               dice3 == dice4 && dice4 == dice5)) {
          //we need to re-roll
          dice1 = rollDice();
          dice2 = rollDice();
          dice3 = rollDice();
          dice4 = rollDice();
          dice5 = rollDice();
          count = count + 1;
      }
      return count;
  }

My Answer: (completed code above) -- correct.


#Warning Alert
So lets write an alarm that goes off for a set number of times, then stops... using a while loop:

  public void raiseAlarm (int numOfWarnings) {
    int i = 1; // referred to as the loop counter.
    while (i <= numOfWarnings) { // loop condition (or 'conditional statement')
      System.out.println("Warning");
      i = i + 1; // Called the loop increment, can also be written as i++
    }
  }

When you call this function with: raiseAlarm(5)...

That sets the 'raiseAlarm' variable to 5.
The counter is 1. So the conditional compares the 1 to the 5 and runs the loop until its no longer true.


#For Loops - Enter the Dragon!
Using the while loop example from above, we can isolate the 3 elements needed to loop over some code:
1) The loop counter (int i = 1;)
2) The loop condition (i <= numOfWarnings)
3) The loop increment (i = i + 1) -or- (i++)

Now, this can be handled in a while loop, sure, but maintaining the loop, and readability are difficult to deal with.

This is where the FOR loop shines. It includes the above 3 key loop elements, all wrapped in one nice line of code.
Here's an example:

  public void raiseAlarm (int numOfWarnings) {
    for (int i = 1; i <= numOfWarnings; i++) {
      // Your codeblock to do things
      System.out.println("Warning");
    }
  }

This houses all 3 of the needed elements for a loop inside the one set of parentheses.


#Loop Counters
You can also use the loop counter inside the codeblock (for example, you want to display what the current count is)
Here's an example:

  public void raiseAlarm (int numOfWarnings) {
    for (int i = 1; i <= numOfWarnings; i++) {
      // Your codeblock to do things
      System.out.println("Warning #" + i);
    }
  }

  raiseAlarm(5); // call the function with this

Output would be:

  Warning #1
  Warning #2
  Warning #3
  Warning #4
  Warning #5

Be careful though, make sure you don't change the value of i inside the codeblock or you might break the loop / create an endless (infinite) loop.


#Count The Blocks
