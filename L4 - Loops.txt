Hello notes! https://classroom.udacity.com/courses/ud282/lessons/8192650550/concepts/38f71cca-9f97-4fbd-baee-7c39914b9376

###L4 Loops

#Loop Types:
There are 3 loop types in Java:

1) While loop - A while loop statement in Java programming language repeatedly executes a target statement as long as a given condition is true.
  while(Boolean_expression) {
     // Statements
  }

2) For loop - A for loop is a repetition control structure that allows you to efficiently write a loop that needs to be executed a specific number of times.
  for(initialization; Boolean_expression; update) {
     // Statements
  }

3) Do-While loop - A do...while loop is similar to a while loop, except that a do...while loop is guaranteed to execute at least one time.
  do {
     // Statements
  }while(Boolean_expression);


#Alarm
Say you wanted to create an alarm that continues to go off until it is stopped.

Here are some functions that help that happen:

  public void beep () {
    // Makes a single beep sound
  }

  public boolean checkAlarm () {
    // Returns true if the alarm is on, false if it is off
  }

  public void alarm () {
    // Keep beeping until it is snoozed
    boolean on = checkAlarm();
    if (on) {
      beep();
      on = checkAlarm(); // but this only runs once... how do we get it to continually check?
    }
  }

In this case we can use a while loop. ;)


#While Loops
while loops allow you to repeat an if condition over and over for as long as that condition remains true, hence the name while!

To create a while loop, simply follow the same steps like an if condition, but replace the if with a while to look something like this:

  while(isRaining){
     System.out.println("It's still raining outside!");
     isRaining = checkWeather();
  }
  System.out.println("Now it's not raining anymore");

This code block above will continue to print the message "It's still raining outside!" for
as long as the boolean isRaining is true, once the function checkWeather() returns false
isRaining will no longer be true, so the while loop would end and the message "Now it's not raining anymore" will be displayed.

Unlike if blocks however, while loops don't have else blocks, they are simply like a repeated if block that would only end when the condition becomes false.


#Quiz - Googol
Can you write a while loop that would print out a googol? (1 with 100 zeroes behind it?)

  String googol = "1"; // Creates a string variable.
  int len = googol.length(); // Creates a length of string variable.

  while (len < 101) { // While length of string is less than 101... do what is in codeblock.
    googol = googol + "0"; // Adds a "0" to the end of the string.
    len = googol.length(); // Reads the length of the new string, and passes that value to the loop.
  }


#Yahtzee! - It's a Match!
The problem we are trying to solve is to count the number of times we need to roll 5 dice to get a Yahtzee.
Instead we should first simplify the problem down to rolling two dice and going from there.

So to simplify, start with writing code that will roll two dice and compare if they are equal or not.
Once you have that code, you can then add more dice to the code, to solve the end problem.

Here is code for rolling two dice:

  public int keeprolling () {
    int dice1 = rollDice(); // stores the value of first dice roll
    int dice2 = rollDice(); // stores the value of the second dice roll
    int count = 1; // Sets a counter to keep track of the number of rolls

    while (!(dice1 == dice2)) { // while the value of dice1 and dice2 is NOT equal, do this
      // We need to re-roll
      dice1 = rollDice(); // stores the value of first dice roll
      dice2 = rollDice(); // stores the value of second dice roll
      count = count + 1; // Increments counter to keep track of retries
    }
    return count; // When they finally match, return the number of tries it took.
  }

So the above handles 2 dice. Starting simple, but we wanted 6... let's keep going.


#Quiz; Three Dice
With the above code, we were able to get the values of two dicerolls and compare their equality.
Now how would we handle if there needed to be a third dice?

  public int keeprolling () {
    int dice1 = rollDice(); // stores the value of first dice roll
    int dice2 = rollDice(); // stores the value of the second dice roll
    int dice3 = rollDice(); // stores the value of the third dice roll
    int count = 1; // Sets a counter to keep track of the number of rolls

    while (!(dice1 == dice2 == dice3)) { // THIS WONT WORK - SO HOW DO WE GET IT TO WORK?
      // We need to re-roll
      dice1 = rollDice(); // stores the value of first dice roll
      dice2 = rollDice(); // stores the value of second dice roll
      dice3 = rollDice(); // stores the value of third dice roll
      count = count + 1; // Increments counter to keep track of retries
    }
    return count; // When they finally match, return the number of tries it took.
  }

What should the conditional statement be instead to get it to work?

My Answer: !(dice1 == dice 2 && dice2 == dice3)

But how does that work?

It will compare the values of dice1 to dice2, and compare the values of dice2 to dice3
If dice1, dice2 AND dice2, dice3 are all equal, then the condition would equate to true... but its !(true) - which evaluates to false, exiting the loop.
If any of them are a mismatch, any of them will cause it to equate to false, and the !(false) equates to true, going into the loop.

That one takes a bit to wrap your head around, go over it a few times to make sure you understand why that would work.

And for funsies, also try to figure out why these would NOT work:

  while (dice1 == dice2 || dice2 == dice3)
  while (dice1 && dice2 && dice2 == dice3)
  while (dice1 != dice2 && dice2 != dice3)

Easiest way to figure out why is to try writing out the examples, with some true and false test values.


Quiz: Roll A Yahtzee
You should modify the function int keepRolling() by adding code to check for a 5 dice match (Yahtzee) rather than just 3 dice.

To do so, follow these steps:

Add 2 new integer variables dice4 and dice5 and initialize them to the function call rollDice()
Then inside the while loop, make sure you reset the values of those integers to another call of rollDice() each.
Finally, update the while loop condition to check for the mismatch of all 5 dice.
Remember you can simply check that all dice match and surround that with the ! not operator like with the existing 3 dice implementation.

  public int keepRolling() {
      int dice1 = rollDice();
      int dice2 = rollDice();
      int dice3 = rollDice();
      int dice4 = rollDice();
      int dice5 = rollDice();
      int count = 1;

      while (!(dice1 == dice2 && dice2 == dice3 &&
               dice3 == dice4 && dice4 == dice5)) {
          //we need to re-roll
          dice1 = rollDice();
          dice2 = rollDice();
          dice3 = rollDice();
          dice4 = rollDice();
          dice5 = rollDice();
          count = count + 1;
      }
      return count;
  }

My Answer: (completed code above) -- correct.


#Warning Alert
So lets write an alarm that goes off for a set number of times, then stops... using a while loop:

  public void raiseAlarm (int numOfWarnings) {
    int i = 1; // referred to as the loop counter.
    while (i <= numOfWarnings) { // loop condition (or 'conditional statement')
      System.out.println("Warning");
      i = i + 1; // Called the loop increment, can also be written as i++
    }
  }

When you call this function with: raiseAlarm(5)...

That sets the 'raiseAlarm' variable to 5.
The counter is 1. So the conditional compares the 1 to the 5 and runs the loop until its no longer true.


#For Loops - Enter the Dragon!
Using the while loop example from above, we can isolate the 3 elements needed to loop over some code:
1) The loop counter (int i = 1;)
2) The loop condition (i <= numOfWarnings)
3) The loop increment (i = i + 1) -or- (i++)

Now, this can be handled in a while loop, sure, but maintaining the loop, and readability are difficult to deal with.

This is where the FOR loop shines. It includes the above 3 key loop elements, all wrapped in one nice line of code.
Here's an example:

  public void raiseAlarm (int numOfWarnings) {
    for (int i = 1; i <= numOfWarnings; i++) {
      // Your codeblock to do things
      System.out.println("Warning");
    }
  }

This houses all 3 of the needed elements for a loop inside the one set of parentheses.


#Loop Counters
You can also use the loop counter inside the codeblock (for example, you want to display what the current count is)
Here's an example:

  public void raiseAlarm (int numOfWarnings) {
    for (int i = 1; i <= numOfWarnings; i++) {
      // Your codeblock to do things
      System.out.println("Warning #" + i);
    }
  }

  raiseAlarm(5); // call the function with this

Output would be:

  Warning #1
  Warning #2
  Warning #3
  Warning #4
  Warning #5

Be careful though, make sure you don't change the value of i inside the codeblock or you might break the loop / create an endless (infinite) loop.


#Quiz - Count The Blocks
You need to implement this function public int countBlocks(int levels) that takes the number of levels as an input argument and
returns the number of blocks required to build a pyramid made up of that many levels.

Remember that for loops help count up to a certain number (which is the value of levels in this case) and inside the loop,
the number of blocks for that level would be the result of multiplying the loop counter by itself (for example i*i)

This means that if for every level, the number of blocks in that level was added to some variable total then by the end of
the loop the total number of blocks needed to build the entire pyramid would be in that total variable and could be returned as the result of that function!

My Answer: (Wrong!!!)
  public int countBlocks (int levels) {
    for (int i = 1; i <= levels; i++) {
      int total = i * i;
    }
    return total;
  }

The CORRECT Answer:
  public int countBlocks (int levels) {
    int total = 0;
    for (int i = 1; i <= levels; i++) {
      total = total + (i * i);
    }
    return total;
  }

// NOTE: take some time to go thru the above code and figure out exactly what its doing.


#Not Just Increment
You don't have to start the counter with 0 or 1, you can do a lot more with it.
In this example, we will use it to Add numbers at each step and return the total sum:

  /* Adds the numbers 15 + 16 + ... + 20
     Returns the total sum of the addition */

  public int addNumbers () {
    int sum = 0;
    for (int i = 15; i <= 20; 1++) {
      sum = sum + i;
    }
    return sum;
  }

So it adds 15, to 16, then to 17, and so on up to (and including) 20 -- stores the result in the variable SUM, and then returns the variable.

Another alternative is to count loops down instead. To do that, you can update the increment from i++ to i-- instead:

  for (int i = 3; i >= 1; i--) {
    // We also have to change the loop counter to start from the higher number
    // We have to change the loop condition to go to the lower number
    // We have to change the increment to a decrement
  }


#Step Faster
Here's a comparison between a while and a for loop:

// While Loop:
  int i = 0;
  while (i <= 10) {
    System.out.println(i);
    i++
  }

// FOR Loop:
  for (int j = 0; j <= 10; j++) {
    System.out.println(j);
  }

There are shorthand ways to write the increment and decrement - but we only saw how to do it by a difference of 1.
Lucky for us, we don't just have to use 1, you can shorthand to any value (and not just addition and subtraction) - shown below:

  Longhand: i = i + 5;
  Shorthand: i += 5;

  Longhand: j = j-6;
  Shorthand: j -= 6;

  Longhand: k = k * 3;
  Shorthand: k *= 3;

  Longhand: l = l / 2;
  Shorthand: l /= 2;

And here's a practical use for it - say you only want to display even numbers in a counter:

  public void evenNumbers () {
    for (int i = 2; i <= 10; i += 2) {
      System.out.println(i);
    }
  }

The above will increment each step by 2, which will cause only even values to display (because the counter also started at an even value)


#Break
Sometimes you will want to end a loop before it completes all the iterations of the counter. Here's an example:

  // WiFi Search

  public void searchWiFi () {
    for (int i = 1; i <= 10; i++) {
      boolean wifiAvailable = checkWifi();
      if (wifiAvailable) {
        System.out.println("WiFi Found!");
        break; // break will cause exit the loop entirely. (Works in for and while loops)
      }
    }
  }

Another example for this:

  // Roll a Six - Rolls the dice until you get a 6, then you win. If you get a 3 you lose.

  public boolean rollASix () {
    int dice = rollDice (); // Creates a variable called 'dice' and sets the value to the result of the 'rollDice' function from earlier.

    while (dice != 6) { // Checks that the value of the 'dice' variable is NOT equal to 6.
      if (dice == 3) { // Checks if the value of the 'dice' variable is 3 (if True, break, you lost.)
        break;
      }
      dice = rollDice (); // If the value of 'dice' is NOT equal to 3, the 'IF' condition ends, and then we reroll the dice.
    }

    if (dice == 6) { // If the 'dice' value was == 6, the while loop would end, and this would check if the value was 6
      return true; // If the value was 6, it would move to this codeblock - which would return TRUE.
    } else { // Otherwise if the value is anything else, do whats in the following codeblock
      return false; // Returns false.
    }
  }

**NOTE: I got confused why this happens... because I thought the 3 breaking out was something special.
It's not. Its the same as returning any other number aside from 6, it just ends the rolling session early.
Because a 6 will return TRUE, and any other number will return FALSE. We don't do anything special if a 3 is rolled, it's still FALSE.


##Quiz - Know When To Quit:
You need to modify the function int martingale() by adding an extra if block that checks if the money value has reached or exceeded
the target specified if(money >= target). If it has, then the code should break out of the while loop using the break; statement

Aside: the Martingale betting system is a terrible idea in practice. You can only keep doubling your bet until you blow through your
entire bankroll, and then you're stuck. For more commentary check out this article on the Martingale betting system.

Add a break to the function below to stop betting at the appropriate time based on the martingale system.

  public int martingale () {
    int money = 1000;
    int target = 1200;
    int bet = 10;
    while (money > bet) {
      boolean win = play();
      if (win) {
          if (money == target) {
            break;
          }
        money += bet;
        bet = 10;
      } else {
        money -+ bet;
        bet *= 2;
      }
    }
    return money;
  }

(My Answer was correct)

##Press Conference
Say we are having a press conference and there are 10 news outlets present. We want to
randomly select one news outlet at a time to ask a question. How can we maintain a list of
all the various news outlets, and how can we go thru that list? Strings? Something else?

This is a prime example for arrays!


#Arrays:
If you have a string variable, you can only store one value in it.
If you have an array, you can store multiple strings all in one variable name. (So going back to the
Press Conference example, this would be a good use case for storing all the news outlet names!)

One limitation however - the data in the array has to be all the same Data Type.

Arrays are indexed (starting at 0) and you can address each value in the position in array using its index. (ie: newsOutlet[5])

Each 'spot' in an array is called a Cell. (You can draw a reference to like, an Excel spreadsheet here)

To declare an array, you would use the following syntax:

  int [] numbers = {22, 234, 1, 64, 2, 67, 883, 34, 6543, 34};

The bonus of using this format: You don't have to specify how many cells are in the array first.

Here's a fun example:

If you have an array of an interger data type, you can use arithmetic against the cells, like this:

  int sum = numbers[0] + numbers[3];

So in your array of 'numbers' - you created a new variable called sum to store the sum of two array cells that you called up via their index.

Of course, if you did that with a string data type, it would concatenate the values (which we've done before)


#Quiz: Array Index
What will be the value of s after running this code?

  double [] fracNumbers = {4.0, 6.2, 3.75, 5.1 9.99};
  double s = fracNumbers[0] + fracNumbers[3];

My Answer: 9.1 (Correct)


#Press Conference Part 2:
Let's declare an array of strings that hold our news outlet names:

  String [] newsOutlet = {"acb", "bbc", "CNN", "CBS", "AP", "NBC", "FOX", "npr", "sky", "Aljazeera"};

Let's tell it to print out one of the cell values:

  System.out.println(newsOutlet[2]);

Which would output: CNN

But to select a random one, we'll need to use Math.random to help...

  String [] newsOutlet = {"acb", "bbc", "CNN", "CBS", "AP", "NBC", "FOX", "npr", "sky", "Aljazeera"};
  double lucky = Math.random;                 // Stores the value of Math.random as 'lucky'
  lucky *= 10;                                // Multiplies the 'lucky' value by 10, moving the decimal place over.
  int luckyIndex = (int) lucky;               // Converts the value 'lucky' from a double into an int (and also a whole number, discarding any fractional values), and stores that value as 'luckyIndex'

  System.out.println(newsOutlet[luckyIndex]); // Prints out the cell value from the newsOutlet array, and the value of the index is set by the variable luckyIndex.


#Arrays and Loops
Arrays can also be passed in as arguments into functions. Functions can also return arrays.

Let's create a function that calculates the average temperature from an array of temperatures.
We'll call it caluclateAverage. It'll take in an array of doubles and return a single double value.

Here's how we would go about it:

  public double calculateAverage (double [] temperatures) {    // creates a function that takes in an array as an argument
    int size = temperatures.length;                            // This will get us the number of values in the Array
    double total = 0;                                          // We need to add up all the items in the Array, and store it as a value (for calculating the average)
    for (int i = 0; i < size; i++) {                           // loops based on the size of the array
      total += temperatures[i];                                // takes the cell value of the 'temperatures' array and stores it in the 'total' variable
    }
    double average = total / size;                             // To calculate the average, you divide the total sum by the number of values (cells)
    return average;                                            // Returns the value of average out of the function
  }

It's always advisable to get the length of the array when working with one, because if you try to
call a cell value that is outside of the array (ie: doesn't exist) you will get an error.

So if the array is int [] num {34, 345, 765, 3434}; and you try to call num[7] it will error out because there is no value or cell at that index.


#Rubiks Champ
Let's write a function that shows us the fastest time to solve a rubiks cube in an array of recorded times:

This was my implementation before seeing the solution:

  double [] speed = {7.85, 7.32, 4.9, 6.22, 5.4, 7.3, 5.19};

  public double search (double [] speed) {
    int size = speed.length;
    int min = 0; // error... didnt declare as double, could have set initial value to speed[0] (first cell in array)
    for (int i = 0; i < size; i++) { // error... (started index at 0, not 1...)
      if (min <= speed[i]) { // error... wrong order of comparison
        min = speed[i];
      }
    }
    return min;
  }

And here is the corrected code:

  double [] speed = {7.85, 7.32, 4.9, 6.22, 5.4, 7.3, 5.19}; // Declares and populates an array

  public double search (double [] speed) {            // Declare a function called 'search' and accepts an array 'speed' as a parameter
    int size = speed.length;                          // Gets the length of the array for the loop counter
    double min = speed[0];                            // Assigns the first array cell value to the 'min' variable - saves a step.
    for (int i = 1; i < size; i++) {                  // loops based on the size of the array
      if (speed[i] <= min) {                          // Compares the array cell value to the stored variable value to see if the cell is smaller
        min = speed[i];                               // If the array cell value is smaller than the stored min value, set min to the new lower value
      }
    }
    return min;                                       // Returns the value of average out of the function
  }


#Quiz - Find the longest name:
Write a function that searches an array of strings and finds the longest string.

You should implement the function String findLongestName(String [] names) which takes an array of
Strings as an input containing a list of names, and return the String that has the longest name.

To do so, try to follow these steps:

1) The first step is to calculate and store the length of the input array, this is done using names.length; and store that in an integer variable.
2) Then create a new String called longestName that will store the longest name in the array of names, initialize it with the first name in the array, that is names[0].
3) Next, you should create a for loop that will compare every name in the array using names[i] against the longestName. Only replace the longestName value if the names[i] is longer .
4) Finally, return the longestName variable as the return value of the function.


My Answer:
  String [] names = {"Todd", "Skippy", "Bob", "Bud", "Samantha", "Horace", "Al"};

  public String findLongestName (String [] names) {
    int size = names.length;
    String longestName = names[0];
    for (int i = 1; i < size; i++) {
      if (names[i] >= longestName) {
        longestName = names[i];
      }
    }
    return longest;
  }

Quiz Solution:

  String [] names = {"Todd", "Skippy", "Bob", "Bud", "Samantha", "Horace", "Al"};

  public String findLongestName (String [] names) {
    int size = names.length;
    String longestName = names[0];
    for (int i = 1; i < size; i++) {
      if (names[i].length() > longestName.length()) {
        longestName = names[i];
      }
    }
    return longest;
  }

Basically, I didn't invoke the .length() correctly


#Quiz - But what if there is a tie?
What happens if there are two names that are the same length? What would the stored value of longestName be?

My answer: "The first longest value" (reasoning - because of the > operator, the other value is NOT longer, and is not replaced.) -- (Correct)


#2D Arrays
These are basically arrays that contain arrays. (An "array of arrays")

Say for example you have some students, who take a few subjects, and each one has a grade.
The Students: Gale, Tim, Sandra, Sam, Eric
The Subjects: Math, English, Biology, Arts
Each student has one grade per subject.

If you were to think of that in excel for example, the "columns" would be the student names, the rows would start with the subjects,
and then you could plot out the grades for the respective students for each subject...

            | [0] Gale  | [1] Tim | [2] Sandra  | [3] Sam | [4] Eric  |
  [0] maths | 87        | 93      | 99          | 75      | 60        |
  [1] engl  | 93        | 70      | 98          | 90      | 75        |
  [2] bio   | 82        | 75      | 95          | 80      | 66        |
  [3] arts  | 90        | 75      | 99          | 85      | 70        |

So to notate what is above, it would look like:

  int [] [] grades

So to find Tims grade in biology: grades [2] [1]
To find Sams grade in english: grades [1] [3]
To find Sandras grade in arts: grades [3] [2]

So to address the 2D array, you first start with the index position of the main array, and then the index of the array within the array.

You could also think of it like this: grades [[87,93,99,75,60], [93,70,98,90,75], [82,75,95,80,66], [90,75,99,85,70]]


#Iterating Over 2D Arrays
So we learned how to iterate over a single array using a for loop. But how do you iterate over a 2D array?

One example is to set the array index, then the array-array's index to a variable, all in a FOR loop, like this:

  for (int i = 0; i < 5; i++) { grades [1][i]; }

In the above example we are just iterating over the second part of the array (or, the array inside the array)

Let's show a practical example: How to calculate the average of grades for a subject in an array:

  public static double englishAverage (int [] [] grades) {      // declares a function called englishAverage and accepts an array as a parameter
    int total = 0;                                              // sets an empty variable called 'total' for adding up all the grades.
    for (int i = 0; i < 5; i++) {                               // Loops over the array using 'i' as the counter
      total += grades [1] [i];                                  // takes the current array cell value and adds it to the 'total' variable
    }
    double average = total/5.0;                                 // Gets the average by dividing the total by the number of values
    return average;                                             // returns the average english grade
  }

Now, what if you wanted to do the same thing, but all the grades for a student, not for a course?
You'd need to iterate thru each array cell for the student index, but also thru the corresponding grades for each course.

Well, in that case, all the grades for a student will be at the same index, and we just need to loop thru each course.

So for Sandras grades, we'd want the values for grades [0][2], grades [1][2], grades [2][2], and so on...

So the loop would look like:

  public static double sandraAverage (int [] [] grades) {      // declares a function called englishAverage and accepts an array as a parameter
    int total = 0;                                              // sets an empty variable called 'total' for adding up all the grades.
    for (int i = 0; i < 4; i++) {                               // Loops over the array using 'i' as the counter
      total += grades [i] [2];                                  // in this case, the '2' is the Sandra index.
    }
    double average = total/4.0;                                 // Gets the average by dividing the total by the number of values
    return average;                                             // returns the average english grade
  }

All of the above assumes that you know what is in the array and how many indexes each dimension has. But what if you had no idea?

Here's how to write out the same function, but without knowing anything about the arrays themselves...

  public static double sandraAverage (int [] [] grades) {       // declares a function called englishAverage and accepts an array as a parameter
    int subjects = grades.length                                // gets the length of the array and stores it as an int value of subjects.
    int total = 0;                                              // sets an empty variable called 'total' for adding up all the grades.
    for (int i = 0; i < subjects; i++) {                        // Loops over the array using 'i' as the counter, and the subjects value as the comparison
      total += grades [i] [2];                                  // in this case, the '2' is the Sandra index.
    }
    double average = total/(double)subjects;                    // Gets the average by dividing the total by the number of values, switching the value of subjects into a double
    return average;                                             // returns the average english grade
  }

Oh no! How do we address the second array/index though? Here's one way:

  public static double studentAverage (int [][] grades, int student) {
    int total = 0;
    int subjects = grades.length;
    for(int i=0; i<subjects; i++) {
      total += grades[i][student];
    }
    double average = total/(double)subjects;
    return average;
  }

For the above code, we made it more general. Now when you call the function, we designbed it so that you can
specify ANY student, using a second parameter value passed to the function (in this case, 'int student').

Inside the function we can set the second array index value to 'student' - total += grades[i][student];
Where we had previously had to specify a hard-coded value for them instead.


#Nested Loops
Say we wanted to go thru every value in each array inside the array... we would need a loop to go thru each array index, and
one more loop that goes through each index for the array inside of the main array.

We can do that using a loop inside a loop.


#Quiz - Inside a Nested Loop
How many times do you think this message will be printed?

  for (int i=0; i<3; i++) {
    for (int j=0; j<3; j++) {
      System.out.println("Hi!");
    }
  }

My Answer: 9 times -- correct.


#How Nested Loops Work
Every time the outer loop (the 'i' loop) runs, it resets the counter for the inner loop (loop j) to 0 again.
So if the inner loop runs 3 times and the outer loop runs 3 times, it runs 9 times:
The inside loop 3 (for the outide loops first run), and then 3 for the inside for the outsides second, and 3 times inside for the outsides 3rd.

So that being said, how can we apply it to our Grades model from above?

  public static double studentAverage (int [][] grades, int student) {
    int total = 0;
    int subjects = grades.length;
    for(int i=0; i < subjects; i++) {
      for (int j=0; j < student; j++) {
        total += grades[i][j];
    }
    double average = total/(double)subjects;
    return average;
  }


#L4 Project:

Q1) What will be printed by this block of Java code?
  int n = 10;
    while (n < 50) {
      n = n * 2;
    }
  System.out.println(n);

My Answer: 80 -- correct.


Q2) Complete the factorial() function below.
It should return the product of all the numbers from 1 to the parameter n.
For example, factorial(5) should return 120 because 1 x 2 x 3 x 4 x 5 = 120.
Think about what kind of loop you want to use to accomplish this.
Starting code:
  public int factorial(int n) {
  }

My Answer:

  public int factorial (int n) {
    int result = 1;
    int count = 1;
    while (count <= n) {
      result = result * count;
      count++;
    }
    return result;
  }

Ok so, my answer was correct, but they handled it in a for loop... here's THEIR solution:

  public int factorial(int n) {
    int factorial = 1;
    for (int i = 1; i <= n; i++) {
      factorial = factorial * i;
    }
    return factorial;
  }

So it's the same thing, I just did it less efficiently.


Q3) Complete the code in this function to find and return the lowest index in the String array stringArray that the String target occurs.
If the String target does not occur in stringArray, -1 should be returned.

Starting code:
  public int indexOfFirstOccurrence(String[] stringArray, String target) {
    return -1;
  }

As an example of how this function should work, this code should print 1, because the word “Java” appears at index 1.

  String[] sentence = {"Learning", "Java", "is", "fun."};
  int indexOfWordJava = indexOfFirstOccurrence(sentence, "Java");
  System.out.println(indexOfWordJava);

Hint: you cannot compare two Strings using the == operator!
This will be false unless the two Strings are actually the same String object, not just two Strings with the same letters.
To check whether two Strings have the same letters, use the equals() method: if (myString1.equals(myString2)).

My Answer:

  public int indexOfFirstOccurrence(String[] stringArray, String target) {
    for (int j=0; j<3; j++) {
        if (stringArray[i].equals(target)) {
          return i;
        }
      } else {
        return -1;
      }
  }

My only error was on line 794 - I did return target; when it should have been return i;
Also, my else statement is implied, so i don't need to declare it. I could have just said 'return -1' outside the for loop.

Here is an example of their solution:

  public int indexOfFirstOccurrence(String[] stringArray, String target) {
    for (int i = 0; i < stringArray.length; i++) {
      if (stringArray[i].equals(target)) {
          return i;
      }
    }
    return -1;
  }

Q4) A savings account yields 5% interest annually.
This Java function is designed to determine how many years it will take for you to have $1,000,000 on deposit given an initial value.
The parameter represents the initial deposit, and the function should return an integer number of years before there will be $1,000,000
or more in the account. Write a loop to determine the number of years, and return that value.

(Hint: Do we know how many times this loop needs to iterate? Does this mean a for loop or a while loop is more appropriate?)

Starting code:
  public int yearsTilOneMillion(double initialBalance) {
    return 0;
  }

My Answer:

  public int yearsTilOneMillion (double initialBalance) {
    int years = 0;
    balance = initialBalance;
    while (balance < 1000000) {
      balance = balance + (balance * .05);
      years++
    }
    return years;
  }

So, my calculation for adding 5% interest was wrong, but overall my code was pretty close. Below is the example solution:

  public int yearsTilOneMillion(double initialBalance) {
    int years = 0;
    double balance = initialBalance;
    while (balance < 1000000) {
      years++;
      balance = balance * 1.05;
    }
    return years;
  }

Q5) Complete the Java function below to print out all the Strings in the String array parameter in reverse order.
(The String at the highest index should be printed first, then the String at the next highest index, and so on.
The String at index 0 should be printed last.)

For example, if a String array called weekdays had value:

  {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday"}

then this function call:

  printInVerverse(weekdays);

would print:

Friday
Thursday
Wednesday
Tuesday
Monday

Starting code:
  public void printInReverse(String[] stringArray) {
  }

My Answer: (correct)

So, we need to get the length of the array, then iterate thru printing the values, but in reverse.
We know this can be done with a FOR loop, and changing the counter and condition and increment.

  public void printInReverse(String[] stringArray) {
    int count = stringArray.length;
    for (int i = count; i > 0; i--) {
      System.out.println(stringArray[i]);
    }
  }

Example solution code:
  public void printInReverse(String[] stringArray) {
    for (int i = 0; i < stringArray.length; i++) {
      //When i has its smallest possible value, 0, the expression
      //below will be the length of the string array minus one,
      //which is the highest index. When i has its largest possible
      //value, stringArray.length - 1, this expression will be
      //0, which is the the lowest index.
      int indexToPrint = stringArray.length - 1 - i;
      System.out.println(stringArray[indexToPrint]);
    }
  }

A neater way to solve this would be to structure the for loop differently. For loop variables
do not need to begin at 0, and do not always need to go up by one. This loop is structured
so that the loop variable i begins at the largest index and decreases by 1 every time the
loop iterates. (The syntax i-- is shorthand for i = i - 1;.)

  public void printInReverse(String[] stringArray) {
    for (int i = stringArray.length - 1; i >= 0; i--) {
      System.out.println(stringArray[i]);
    }
  }

Q6) ....
